use std::collections::HashMap;
use std::path::Path;

use lazy_static::lazy_static;
use regex::Regex;

pub const DEFAULT_ICON: &str = "";
#[allow(dead_code)]
pub const DEFAULT_ICONIZED: &str = " ";
pub const FOLDER_ICON: &str = "";
pub const DEFAULT_FILER_ICON: &str = "";

// The code is generated by ../update_icon_constants.py
//
// constants.rs declares these two variables:
//
// pub static ref EXACTMATCH_MAP: HashMap<&'static str, &'static str>
// pub static ref EXTENSION_MAP: HashMap<&'static str, &'static str>
include!("constants.rs");

#[inline]
pub fn icon_for_path(path: &Path) -> &str {
    path.file_name()
        .and_then(std::ffi::OsStr::to_str)
        .and_then(|ext| {
            let ext: &str = &ext.to_lowercase();
            EXACTMATCH_MAP.get(ext)
        })
        .unwrap_or_else(|| {
            path.extension()
                .and_then(std::ffi::OsStr::to_str)
                .and_then(|ext| EXTENSION_MAP.get(ext))
                .unwrap_or(&DEFAULT_ICON)
        })
}

fn icon_for(line: &str) -> &str {
    let path = Path::new(line);
    icon_for_path(&path)
}

pub fn prepend_icon(line: &str) -> String {
    format!("{} {}", icon_for(line), line)
}

#[inline]
pub fn icon_for_filer(path: &Path) -> &str {
    if path.is_dir() {
        FOLDER_ICON
    } else {
        path.file_name()
            .and_then(std::ffi::OsStr::to_str)
            .and_then(|ext| {
                let ext: &str = &ext.to_lowercase();
                EXACTMATCH_MAP.get(ext)
            })
            .unwrap_or_else(|| {
                path.extension()
                    .and_then(std::ffi::OsStr::to_str)
                    .and_then(|ext| EXTENSION_MAP.get(ext))
                    .unwrap_or(&DEFAULT_FILER_ICON)
            })
    }
}

pub fn prepend_filer_icon(path: &Path, line: &str) -> String {
    format!("{} {}", icon_for_filer(path), line)
}

#[allow(dead_code)]
pub fn prepend_grep_icon(line: &str) -> String {
    lazy_static! {
        static ref RE: Regex = Regex::new(r"^(.*):\d+:\d+:").unwrap();
    }
    let icon = RE
        .captures(line)
        .and_then(|cap| cap.get(1))
        .map(|m| icon_for(m.as_str()))
        .unwrap_or(DEFAULT_ICON);
    format!("{} {}", icon, line)
}
